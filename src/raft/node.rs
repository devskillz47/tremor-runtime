// Copyright 2022, The Tremor Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! The entirety of a cluster node as a struct
use std::{
    collections::BTreeMap,
    path::{Path, PathBuf},
    sync::Arc,
};

use crate::errors::Result;
use crate::system::ShutdownMode;
use crate::{
    raft::{
        network::{api, management},
        ClusterResult, TremorNetwork, TremorNode, TremorNodeId, TremorStore, TremorTypeConfig,
    },
    system::{Runtime, WorldConfig},
};
use async_std::{
    channel::{bounded, Sender},
    net::ToSocketAddrs,
    task::{self, JoinHandle},
};
use futures::{future, prelude::*};
use openraft::{Config, Raft};
use tarpc::{
    server::{self, Channel},
    tokio_serde::formats::Json,
};

use super::{
    app::TremorApp,
    network::{raft::RaftServer, Raft as TarPCRaftService},
    ClusterError,
};

#[derive(Clone, Debug)]
pub struct ClusterNodeKillSwitch {
    sender: Sender<ShutdownMode>,
}

impl ClusterNodeKillSwitch {
    /// Stop the running node with the given `mode`
    pub fn stop(&self, mode: ShutdownMode) -> ClusterResult<()> {
        self.sender
            .try_send(mode)
            .map_err(|_| ClusterError::from("Error stopping cluster node"))
    }
}

pub struct RunningClusterNode {
    kill_switch_tx: Sender<ShutdownMode>,
    run_handle: JoinHandle<ClusterResult<()>>,
}

impl RunningClusterNode {
    async fn start(
        raft: Raft<TremorTypeConfig, TremorNetwork, Arc<TremorStore>>,
        server_state: Arc<TremorApp>,
        runtime: Runtime,
        runtime_handle: JoinHandle<Result<()>>,
    ) -> ClusterResult<Self> {
        let (kill_switch_tx, kill_switch_rx) = bounded(1);

        let tcp_server_state = server_state.clone();
        let mut listener =
            tarpc::serde_transport::tcp::listen(&server_state.rpc_addr, Json::default).await?;
        listener.config_mut().max_frame_length(usize::MAX);

        let http_api_addr = server_state.api_addr.clone();
        let mut http_api_server = tide::Server::with_state(server_state);
        management::install_rest_endpoints(&mut http_api_server);
        api::install_rest_endpoints(&mut http_api_server);
        let run_handle = task::spawn(async move {
            let mut tcp_future = Box::pin(
                listener
                    // Ignore accept errors.
                    .filter_map(|r| future::ready(r.ok()))
                    .map(server::BaseChannel::with_defaults)
                    // Limit channels to 1 per IP.
                    // FIXME .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                    // serve is generated by the service attribute. It takes as input any type implementing
                    // the generated World trait.
                    .map(|channel| {
                        let server = RaftServer::new(tcp_server_state.clone());
                        channel.execute(server.serve())
                    })
                    // Max 10 channels.
                    .buffer_unordered(10)
                    .for_each(|_| async {})
                    .fuse(),
            );
            let mut http_future = Box::pin(http_api_server.listen(http_api_addr).fuse());
            let mut runtime_future = Box::pin(runtime_handle.fuse());
            let mut kill_switch_future = Box::pin(kill_switch_rx.recv().fuse());
            futures::select! {
                _ = tcp_future => {
                    warn!("TCP cluster API shutdown.");
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                    runtime.stop(ShutdownMode::Graceful).await?;
                    runtime_future.await?;
                }
                http_res = http_future => {
                    if let Err(e) = http_res {
                        error!("HTTP cluster API failed: {e}");
                    }
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                    runtime.stop(ShutdownMode::Graceful).await?;
                    runtime_future.await?;

                }
                runtime_res = runtime_future => {
                    if let Err(e) = runtime_res {
                        error!("Local runtime failed: {e}");
                    }
                    // runtime is already down, we only need to stop local raft
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                }
                mode = kill_switch_future => {
                    let mode = mode.unwrap_or(ShutdownMode::Forceful);
                    info!("Tremor cluster node stopping with {mode:?}");
                    // tcp and http api stopped listening as we don't poll them no more
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                    runtime.stop(mode).await?;
                    runtime_future.await?;
                }
            }
            info!("Tremor cluster node stopped");
            Ok::<(), ClusterError>(())
        });

        Ok(Self {
            kill_switch_tx,
            run_handle,
        })
    }

    /// get a kill-switch
    pub fn kill_switch(&self) -> ClusterNodeKillSwitch {
        ClusterNodeKillSwitch {
            sender: self.kill_switch_tx.clone(),
        }
    }

    /// block until the cluster node is done noodling
    pub async fn join(self) -> ClusterResult<()> {
        self.run_handle.await
    }
}

/// internal struct carrying all data to start a cluster node
/// and keeps all the state for an ordered clean shutdown
#[derive(Clone)]
pub struct ClusterNode {
    // static configuration stuff to actually start the node
    id: TremorNodeId,
    api_addr: String,
    rpc_addr: String,
    db_dir: PathBuf,
    raft_config: Arc<Config>,
}

impl ClusterNode {
    pub fn new(
        id: TremorNodeId,
        rpc_addr: impl Into<String> + ToSocketAddrs,
        api_addr: impl Into<String> + ToSocketAddrs,
        db_dir: impl AsRef<Path>,
        raft_config: Config,
    ) -> Self {
        Self {
            id,
            api_addr: api_addr.into(),
            rpc_addr: rpc_addr.into(),
            db_dir: PathBuf::from(db_dir.as_ref()),
            raft_config: Arc::new(raft_config),
        }
    }

    pub async fn bootstrap_as_single_node_cluster(&mut self) -> ClusterResult<RunningClusterNode> {
        let world_config = WorldConfig::default(); // TODO: make configurable
        let (runtime, runtime_handle) = Runtime::start(world_config).await?;
        let store = TremorStore::bootstrap(
            &self.db_dir,
            self.id,
            &self.rpc_addr,
            &self.api_addr,
            runtime.clone(),
        )
        .await?;
        let network = TremorNetwork::new();
        let raft = Raft::new(self.id, self.raft_config.clone(), network, store.clone());

        let mut nodes = BTreeMap::new();
        nodes.insert(
            self.id.clone(),
            TremorNode {
                api_addr: self.api_addr.clone(),
                rpc_addr: self.rpc_addr.clone(),
            },
        );
        raft.initialize(nodes).await?;
        let server_state = Arc::new(TremorApp {
            id: self.id,
            api_addr: self.api_addr.clone(),
            rpc_addr: self.rpc_addr.clone(),
            raft: raft.clone(),
            store,
        });
        RunningClusterNode::start(raft, server_state, runtime, runtime_handle).await
    }
}
