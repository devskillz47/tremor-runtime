// Copyright 2022, The Tremor Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! The entirety of a cluster node as a struct
use crate::{
    errors::Result,
    raft::{
        app, client,
        network::{api, management, raft, Raft as TarPCRaftService},
        store::Store,
        ClusterError, ClusterResult, Network, NodeId, TremorNode,
    },
    system::{Runtime, ShutdownMode, WorldConfig},
};
use async_std::{
    channel::{bounded, Sender},
    net::ToSocketAddrs,
    prelude::FutureExt,
    task::{self, JoinHandle},
};
use futures::{future, prelude::*};
use openraft::{Config, Raft};
use std::{
    collections::{BTreeMap, BTreeSet},
    fmt::Display,
    path::{Path, PathBuf},
    sync::Arc,
    time::Duration,
};
use tarpc::{
    server::{self, Channel},
    tokio_serde::formats::Json,
};

use super::store::{TremorRequest, TremorResponse};

#[derive(Clone, Debug)]
pub struct ClusterNodeKillSwitch {
    sender: Sender<ShutdownMode>,
}

impl ClusterNodeKillSwitch {
    /// Stop the running node with the given `mode`
    /// # Errors
    /// if the node is already stopped or failed to be stopped
    pub fn stop(&self, mode: ShutdownMode) -> ClusterResult<()> {
        self.sender
            .try_send(mode)
            .map_err(|_| ClusterError::from("Error stopping cluster node"))
    }
}

pub struct Running {
    node: Node,
    kill_switch_tx: Sender<ShutdownMode>,
    run_handle: JoinHandle<ClusterResult<()>>,
}

impl Running {
    #[must_use]
    pub fn api_addr(&self) -> &str {
        self.node.api_addr()
    }
    #[must_use]
    pub fn node_id(&self) -> NodeId {
        self.node.node_id()
    }
    #[must_use]
    pub fn node(&self) -> &Node {
        &self.node
    }

    async fn start(
        node: Node,
        raft: Raft<TremorRequest, TremorResponse, Network, Arc<Store>>,
        server_state: Arc<app::Tremor>,
        runtime: Runtime,
        runtime_handle: JoinHandle<Result<()>>,
    ) -> ClusterResult<Self> {
        let (kill_switch_tx, kill_switch_rx) = bounded(1);

        let tcp_server_state = server_state.clone();
        let mut listener =
            tarpc::serde_transport::tcp::listen(&server_state.rpc_addr, Json::default).await?;
        listener.config_mut().max_frame_length(usize::MAX);

        let http_api_addr = server_state.api_addr.clone();
        let mut http_api_server = tide::Server::with_state(server_state);
        management::install_rest_endpoints(&mut http_api_server);
        api::install_rest_endpoints(&mut http_api_server);
        let run_handle = task::spawn(async move {
            let mut tcp_future = Box::pin(
                listener
                    // Ignore accept errors.
                    .filter_map(|r| future::ready(r.ok()))
                    .map(server::BaseChannel::with_defaults)
                    // Limit channels to 1 per IP.
                    // FIXME .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                    // serve is generated by the service attribute. It takes as input any type implementing
                    // the generated World trait.
                    .map(|channel| {
                        let server = raft::Server::new(tcp_server_state.clone());
                        channel.execute(server.serve())
                    })
                    // Max 10 channels.
                    .buffer_unordered(10)
                    .for_each(|_| async {})
                    .fuse(),
            );
            let mut http_future = Box::pin(http_api_server.listen(http_api_addr).fuse());
            let mut runtime_future = Box::pin(runtime_handle.fuse());
            let mut kill_switch_future = Box::pin(kill_switch_rx.recv().fuse());
            futures::select! {
                _ = tcp_future => {
                    warn!("TCP cluster API shutdown.");
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                    runtime.stop(ShutdownMode::Graceful).await?;
                    runtime_future.await?;
                }
                http_res = http_future => {
                    if let Err(e) = http_res {
                        error!("HTTP cluster API failed: {e}");
                    }
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                    runtime.stop(ShutdownMode::Graceful).await?;
                    runtime_future.await?;

                }
                runtime_res = runtime_future => {
                    if let Err(e) = runtime_res {
                        error!("Local runtime failed: {e}");
                    }
                    // runtime is already down, we only need to stop local raft
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                }
                shutdown_mode = kill_switch_future => {
                    let shutdown_mode = shutdown_mode.unwrap_or(ShutdownMode::Forceful);
                    info!("Tremor cluster node stopping in {shutdown_mode:?} mode");
                    // tcp and http api stopped listening as we don't poll them no more
                    raft.shutdown().await.map_err(|_| ClusterError::from("Error shutting down local raft node"))?;
                    runtime.stop(shutdown_mode).await?;
                    runtime_future.await?;
                }
            }
            info!("Tremor cluster node stopped");
            Ok::<(), ClusterError>(())
        });

        Ok(Self {
            node,
            kill_switch_tx,
            run_handle,
        })
    }

    /// get a kill-switch
    #[must_use]
    pub fn kill_switch(&self) -> ClusterNodeKillSwitch {
        ClusterNodeKillSwitch {
            sender: self.kill_switch_tx.clone(),
        }
    }

    /// block until the cluster node is done noodling
    ///
    /// # Errors
    /// if the node failed to run
    pub async fn join(self) -> ClusterResult<()> {
        self.run_handle.await
    }

    /// # Errors
    /// when the cluster can't be joined
    pub async fn join_cluster(
        &self,
        endpoint: impl ToString + Display,
        voter: bool,
    ) -> ClusterResult<()> {
        // try to contact the endpoint
        let my_id = self.node.id;
        debug!("Establishing connectivity to {endpoint}");
        let mut client = client::Tremor::new(my_id, endpoint.to_string());

        let timeout = Duration::from_secs(5);
        let metrics = client
            .metrics()
            .timeout(timeout)
            .await
            .map_err(|_| {
                format!(
                    "Timeout connecting to {endpoint} after {}s",
                    timeout.as_secs()
                )
            })?
            .map_err(|e| format!("Error connecting to {endpoint}: {e}"))?;

        // check if we are already part of the cluster an endpoint is pointing at
        for config in metrics.membership_config.membership.get_joint_config() {
            if config.contains(&my_id) {
                info!(
                    "Already voter of cluster at endpoint: {}",
                    endpoint.to_string()
                );
                return Ok(());
            }
        }

        // find out who the leader is
        let leader_id = metrics.current_leader.ok_or("No leader present!")?;

        let leader = metrics.membership_config.get_node(&leader_id);
        let leader_addr = leader.api_addr.clone();

        // contact the leader directly
        let mut client = client::Tremor::new(leader_id, leader_addr.clone());

        info!("Joining {leader_addr} as Learner");
        client
            .add_learner(
                my_id,
                self.node.rpc_addr.clone(),
                self.node.api_addr.clone(),
            )
            .await
            .map_err(|e| format!("Failed to add learner: {e}"))?;

        info!("Waiting until we have joined");
        let mut membership: BTreeSet<_>;
        loop {
            task::sleep(Duration::from_secs(1)).await;

            let metrics = client.metrics().await.map_err(|e| format!("error: {e}"))?;

            if !metrics
                .membership_config
                .nodes()
                .any(|(id, _)| id == &my_id)
            {
                continue;
            }

            membership = metrics
                .membership_config
                .nodes()
                .map(|(id, _)| *id)
                .collect();
            membership.insert(my_id);
            break;
        }
        if voter {
            info!("Joining the cluster as a voting member...");

            client
                .change_membership(&membership)
                .await
                .map_err(|e| format!("Failed to update membershipo learner: {e}"))?;
        }
        Ok(())
    }
}

/// internal struct carrying all data to start a cluster node
/// and keeps all the state for an ordered clean shutdown
#[derive(Clone)]
pub struct Node {
    // static configuration stuff to actually start the node
    id: NodeId,
    api_addr: String,
    rpc_addr: String,
    db_dir: PathBuf,
    raft_config: Arc<Config>,
}

impl Node {
    #[must_use]
    pub fn api_addr(&self) -> &str {
        &self.api_addr
    }
    #[must_use]
    pub fn node_id(&self) -> NodeId {
        self.id
    }
    pub fn new(
        id: NodeId,
        rpc_addr: impl Into<String> + ToSocketAddrs,
        api_addr: impl Into<String> + ToSocketAddrs,
        db_dir: impl AsRef<Path>,
        raft_config: Config,
    ) -> Self {
        Self {
            id,
            api_addr: api_addr.into(),
            rpc_addr: rpc_addr.into(),
            db_dir: PathBuf::from(db_dir.as_ref()),
            raft_config: Arc::new(raft_config),
        }
    }

    /// Load the latest state from `db_dir`
    /// and start the cluster with it
    ///
    /// # Errors
    /// if the store does not exist, is not properly initialized
    pub async fn load_from_store(
        db_dir: impl AsRef<Path> + ToSocketAddrs,
        raft_config: Config,
    ) -> ClusterResult<Running> {
        let world_config = WorldConfig::default(); // TODO: make configurable
        let (runtime, runtime_handle) = Runtime::start(world_config).await?;

        let store = Store::load(&db_dir, runtime.clone()).await?;
        // ensure we have working node data
        let (node_id, api_addr, rpc_addr) = store.get_node_data()?;
        let node = Self::new(node_id, &rpc_addr, &api_addr, db_dir, raft_config.clone());

        let network = Network::new();
        let raft = Raft::new(node.id, node.raft_config.clone(), network, store.clone());
        let server_state = Arc::new(app::Tremor {
            id: node_id,
            api_addr,
            rpc_addr,
            raft: raft.clone(),
            store,
        });
        Running::start(node, raft, server_state, runtime, runtime_handle).await
    }

    /// Just start the cluster node and let it do whatever it does
    /// # Errors
    /// when the node can't be started
    pub async fn start(&mut self) -> ClusterResult<Running> {
        let world_config = WorldConfig::default(); // TODO: make configurable
        let (runtime, runtime_handle) = Runtime::start(world_config).await?;
        let store = Store::bootstrap(
            &self.db_dir,
            self.id,
            &self.rpc_addr,
            &self.api_addr,
            runtime.clone(),
        )
        .await?;
        let network = Network::new();
        let raft = Raft::new(self.id, self.raft_config.clone(), network, store.clone());
        let server_state = Arc::new(app::Tremor {
            id: self.id,
            api_addr: self.api_addr.clone(),
            rpc_addr: self.rpc_addr.clone(),
            raft: raft.clone(),
            store,
        });
        Running::start(self.clone(), raft, server_state, runtime, runtime_handle).await
    }

    /// Bootstrap and start this cluster node as a single node cluster
    /// of which it immediately becomes the leader.
    /// # Errors
    /// if bootstrapping a a leader fails
    pub async fn bootstrap_as_single_node_cluster(&mut self) -> ClusterResult<Running> {
        let world_config = WorldConfig::default(); // TODO: make configurable
        let (runtime, runtime_handle) = Runtime::start(world_config).await?;
        let store = Store::bootstrap(
            &self.db_dir,
            self.id,
            &self.rpc_addr,
            &self.api_addr,
            runtime.clone(),
        )
        .await?;
        let network = Network::new();
        let raft = Raft::new(self.id, self.raft_config.clone(), network, store.clone());

        let mut nodes = BTreeMap::new();
        nodes.insert(
            self.id,
            TremorNode {
                api_addr: self.api_addr.clone(),
                rpc_addr: self.rpc_addr.clone(),
            },
        );
        // this is the crucial bootstrapping step
        raft.initialize(nodes).await?;
        let server_state = Arc::new(app::Tremor {
            id: self.id,
            api_addr: self.api_addr.clone(),
            rpc_addr: self.rpc_addr.clone(),
            raft: raft.clone(),
            store,
        });
        Running::start(self.clone(), raft, server_state, runtime, runtime_handle).await
    }
}
